/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VibeKanbanPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/types.ts
var DEFAULT_EXECUTOR = "CLAUDE_CODE";
var DEFAULT_EXECUTOR_VARIANTS = ["DEFAULT", "PLAN", "APPROVALS"];
function formatErrorMessage(context, error) {
  const message = error instanceof Error ? error.message : String(error);
  return `${context}: ${message}`;
}
var DEFAULT_SETTINGS = {
  vkUrl: "",
  defaultProjectId: "",
  defaultExecutor: "CLAUDE_CODE",
  defaultVariant: "DEFAULT",
  defaultBranch: "main",
  cardsFolder: "Cards",
  autoPushOnSave: false,
  showStatusBar: true,
  autoSyncStatus: true,
  openInObsidian: true,
  debug: false
};
function parseExecutorProfiles(profiles) {
  const result = [];
  for (const [executor, variants] of Object.entries(profiles.executors)) {
    result.push({
      executor,
      variants: Object.keys(variants)
    });
  }
  return result;
}

// src/api.ts
var import_obsidian = require("obsidian");
var VKApiClient = class {
  // 30 second timeout
  constructor(baseUrl) {
    this.timeout = 3e4;
    this.baseUrl = baseUrl.replace(/\/$/, "");
  }
  setBaseUrl(url) {
    this.baseUrl = url.replace(/\/$/, "");
  }
  async request(method, path, body) {
    var _a;
    const url = `${this.baseUrl}${path}`;
    const params = {
      url,
      method,
      headers: {
        "Content-Type": "application/json"
      },
      throw: false
      // Handle errors manually for better error messages
    };
    if (body) {
      params.body = JSON.stringify(body);
    }
    let timeoutId;
    try {
      const timeoutPromise = new Promise((_, reject) => {
        timeoutId = setTimeout(
          () => reject(new Error(`Request timeout after ${this.timeout}ms`)),
          this.timeout
        );
      });
      const response = await Promise.race([
        (0, import_obsidian.requestUrl)(params),
        timeoutPromise
      ]);
      if (timeoutId)
        clearTimeout(timeoutId);
      if (response.status < 200 || response.status >= 300) {
        const errorMessage = ((_a = response.json) == null ? void 0 : _a.message) || `HTTP ${response.status}`;
        throw new Error(`${method} ${path} failed: ${errorMessage}`);
      }
      const data = response.json;
      if (!data.success) {
        throw new Error(`${method} ${path} failed: ${data.message || "API request failed"}`);
      }
      return data.data;
    } catch (error) {
      if (timeoutId)
        clearTimeout(timeoutId);
      if (error instanceof Error) {
        if (!error.message.includes(path)) {
          error.message = `${method} ${path} failed: ${error.message}`;
        }
        throw error;
      }
      throw new Error(`${method} ${path} failed: ${error}`);
    }
  }
  // Connection test
  async testConnection() {
    try {
      await this.getProjects();
      return true;
    } catch (e) {
      return false;
    }
  }
  // Projects
  async getProjects() {
    return this.request("GET", "/api/projects");
  }
  async getProject(projectId) {
    return this.request("GET", `/api/projects/${encodeURIComponent(projectId)}`);
  }
  async getProjectBranches(projectId) {
    return this.request(
      "GET",
      `/api/projects/${encodeURIComponent(projectId)}/branches`
    );
  }
  // Tasks
  async getTasks(projectId) {
    return this.request(
      "GET",
      `/api/tasks?project_id=${encodeURIComponent(projectId)}`
    );
  }
  async getTask(taskId) {
    return this.request("GET", `/api/tasks/${encodeURIComponent(taskId)}`);
  }
  async createTask(payload) {
    return this.request("POST", "/api/tasks", payload);
  }
  async updateTask(taskId, payload) {
    return this.request("PUT", `/api/tasks/${encodeURIComponent(taskId)}`, payload);
  }
  // Task Attempts
  async createTaskAttempt(payload) {
    return this.request("POST", "/api/task-attempts", payload);
  }
  async getTaskAttempts(taskId) {
    return this.request(
      "GET",
      `/api/task-attempts?task_id=${encodeURIComponent(taskId)}`
    );
  }
  async getTaskAttempt(attemptId) {
    return this.request("GET", `/api/task-attempts/${encodeURIComponent(attemptId)}`);
  }
  // Executor Profiles
  async getProfiles() {
    const response = await this.request(
      "GET",
      "/api/profiles"
    );
    return JSON.parse(response.content);
  }
};

// src/frontmatter.ts
var FrontmatterManager = class {
  // Per-file update queue
  constructor(app) {
    this.updateQueues = /* @__PURE__ */ new Map();
    this.app = app;
  }
  /**
   * Read VK-related frontmatter from a file
   */
  async read(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = (cache == null ? void 0 : cache.frontmatter) || {};
    return {
      title: frontmatter.title,
      vk_project_name: frontmatter.vk_project_name,
      vk_project_id: frontmatter.vk_project_id,
      vk_task_id: frontmatter.vk_task_id,
      vk_status: frontmatter.vk_status,
      vk_executing: frontmatter.vk_executing,
      vk_last_synced: frontmatter.vk_last_synced,
      vk_attempt_id: frontmatter.vk_attempt_id,
      vk_branch: frontmatter.vk_branch,
      vk_pr_url: frontmatter.vk_pr_url,
      vk_executor: frontmatter.vk_executor
    };
  }
  /**
   * Update VK-related frontmatter fields (merges with existing)
   * Uses a per-file queue to prevent concurrent update race conditions
   */
  async update(file, updates) {
    const filePath = file.path;
    const existingQueue = this.updateQueues.get(filePath) || Promise.resolve();
    const updatePromise = existingQueue.then(async () => {
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        for (const [key, value] of Object.entries(updates)) {
          if (value !== void 0) {
            frontmatter[key] = value;
          }
        }
      });
    }).finally(() => {
      if (this.updateQueues.get(filePath) === updatePromise) {
        this.updateQueues.delete(filePath);
      }
    });
    this.updateQueues.set(filePath, updatePromise);
    await updatePromise;
  }
  /**
   * Get the title from frontmatter or filename
   */
  async getTitle(file) {
    const fm = await this.read(file);
    return fm.title || file.basename;
  }
  /**
   * Get the description (body content without frontmatter)
   */
  async getDescription(file) {
    const content = await this.app.vault.read(file);
    const frontmatterRegex = /^---\r?\n[\s\S]*?\r?\n---\r?\n*/;
    const body = content.replace(frontmatterRegex, "").trim();
    return body;
  }
  /**
   * Check if file has VK integration (has vk_task_id)
   */
  async isSynced(file) {
    const fm = await this.read(file);
    return !!fm.vk_task_id;
  }
  /**
   * Get current VK status
   */
  async getStatus(file) {
    const fm = await this.read(file);
    return fm.vk_status || null;
  }
  /**
   * Mark as synced with VK task
   */
  async markSynced(file, taskId, projectId, projectName, status = "todo") {
    await this.update(file, {
      vk_task_id: taskId,
      vk_project_name: projectName,
      vk_project_id: projectId,
      vk_status: status,
      vk_last_synced: new Date().toISOString()
    });
  }
  /**
   * Update execution status
   */
  async updateExecutionStatus(file, status, attemptId, branch, executing) {
    const updates = {
      vk_status: status,
      vk_last_synced: new Date().toISOString()
    };
    if (attemptId) {
      updates.vk_attempt_id = attemptId;
    }
    if (branch) {
      updates.vk_branch = branch;
    }
    if (executing !== void 0) {
      updates.vk_executing = executing;
    }
    await this.update(file, updates);
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var VKSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.projects = [];
    this.executorOptions = [];
    this.lastConnectionStatus = null;
    this.projectsLoadFailed = false;
    this.debounceTimer = null;
    this.plugin = plugin;
  }
  hide() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = null;
    }
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const wrapper = containerEl.createDiv({ cls: "vk-settings" });
    wrapper.createEl("h1", { text: "KanDo", cls: "vk-main-title" });
    wrapper.createEl("p", { text: "Think. Plan. Do.", cls: "vk-tagline" });
    this.lastConnectionStatus = null;
    if (this.plugin.settings.vkUrl) {
      try {
        await this.loadProjects();
        await this.loadProfiles();
        if (this.projects.length > 0) {
          this.lastConnectionStatus = "connected";
        }
      } catch (error) {
        console.error("[KanDo] Error loading settings data:", error);
        this.lastConnectionStatus = "disconnected";
      }
    }
    const folders = this.getFolders();
    let variantDropdownEl = null;
    const connCard = this.createCard(wrapper, "Connection Settings", "globe");
    const connContainer = connCard.createDiv({ cls: "vk-settings-column" });
    const urlGroup = connContainer.createDiv({ cls: "vk-input-group" });
    urlGroup.createDiv({ cls: "vk-input-label", text: "Vibe Kanban URL" });
    urlGroup.createDiv({ cls: "vk-input-description", text: "The URL where Vibe Kanban is running" });
    const inputWrapper = urlGroup.createDiv({ cls: "vk-url-input-wrapper" });
    const urlInput = inputWrapper.createEl("input", {
      cls: "vk-text-input",
      type: "text",
      value: this.plugin.settings.vkUrl,
      placeholder: "http://localhost:5173"
    });
    const statusIcon = inputWrapper.createSpan({ cls: "vk-status-icon-input" });
    if (this.lastConnectionStatus === "connected") {
      (0, import_obsidian2.setIcon)(statusIcon, "check");
      statusIcon.addClass("connected");
    } else if (this.lastConnectionStatus === "disconnected") {
      (0, import_obsidian2.setIcon)(statusIcon, "x");
      statusIcon.addClass("disconnected");
    }
    urlInput.addEventListener("input", async () => {
      this.plugin.settings.vkUrl = urlInput.value;
      await this.plugin.saveSettings();
      this.plugin.api.setBaseUrl(urlInput.value);
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
        this.debounceTimer = null;
      }
      statusIcon.empty();
      statusIcon.className = "vk-status-icon-input";
      if (!urlInput.value)
        return;
      this.debounceTimer = setTimeout(async () => {
        (0, import_obsidian2.setIcon)(statusIcon, "loader-2");
        statusIcon.addClass("loading");
        try {
          await this.plugin.api.getProjects();
          statusIcon.empty();
          statusIcon.className = "vk-status-icon-input";
          (0, import_obsidian2.setIcon)(statusIcon, "check");
          statusIcon.addClass("connected");
          this.lastConnectionStatus = "connected";
          await this.plugin.updateWebSocketConnection();
          this.display();
        } catch (e) {
          statusIcon.empty();
          statusIcon.className = "vk-status-icon-input";
          (0, import_obsidian2.setIcon)(statusIcon, "x");
          statusIcon.addClass("disconnected");
          this.lastConnectionStatus = "disconnected";
        }
      }, 500);
    });
    const projCard = this.createCard(wrapper, "Project Defaults", "box");
    const projGrid = projCard.createDiv({ cls: "vk-settings-grid" });
    const projLeftCol = projGrid.createDiv({ cls: "vk-settings-column" });
    this.createColumnHeader(projLeftCol, "Project & Executor");
    this.createDropdownInput(projLeftCol, {
      label: "Default Project",
      description: "Project to use when creating new cards",
      options: this.projectsLoadFailed ? [{ value: "", label: "Connection failed - check URL" }] : this.projects.length === 0 ? [{ value: "", label: "No projects in Vibe Kanban" }] : [
        { value: "", label: "Select a project" },
        ...this.projects.map((p) => ({ value: p.id, label: p.name }))
      ],
      value: this.plugin.settings.defaultProjectId,
      onChange: async (value) => {
        this.plugin.settings.defaultProjectId = value;
        await this.plugin.saveSettings();
      }
    });
    this.createDropdownInput(projLeftCol, {
      label: "Default Executor",
      description: "AI agent to execute tasks",
      options: this.executorOptions.length === 0 ? [{ value: DEFAULT_EXECUTOR, label: DEFAULT_EXECUTOR.replace(/_/g, " ") }] : this.executorOptions.map((o) => ({
        value: o.executor,
        label: o.executor.replace(/_/g, " ")
      })),
      value: this.plugin.settings.defaultExecutor,
      onChange: async (value) => {
        this.plugin.settings.defaultExecutor = value;
        await this.plugin.saveSettings();
        this.updateVariantDropdown(variantDropdownEl);
      }
    });
    const projRightCol = projGrid.createDiv({ cls: "vk-settings-column" });
    this.createColumnHeader(projRightCol, "Variant & Branch");
    const variantContainer = this.createDropdownInput(projRightCol, {
      label: "Default Variant",
      description: "Executor mode (e.g., DEFAULT, PLAN)",
      options: [],
      // Will be populated dynamically
      value: this.plugin.settings.defaultVariant,
      onChange: async (value) => {
        this.plugin.settings.defaultVariant = value;
        await this.plugin.saveSettings();
      }
    });
    variantDropdownEl = variantContainer.querySelector("select");
    this.populateVariantDropdown(variantDropdownEl);
    this.createTextInput(projRightCol, {
      label: "Default Base Branch",
      description: "Git branch to use as base for PRs",
      placeholder: "main",
      value: this.plugin.settings.defaultBranch,
      onChange: async (value) => {
        this.plugin.settings.defaultBranch = value;
        await this.plugin.saveSettings();
      }
    });
    const syncCard = this.createCard(wrapper, "Synchronization", "refresh-cw");
    const syncGrid = syncCard.createDiv({ cls: "vk-settings-grid" });
    const syncLeftCol = syncGrid.createDiv({ cls: "vk-settings-column" });
    this.createColumnHeader(syncLeftCol, "Folders");
    this.createFolderInput(syncLeftCol, {
      label: "Cards Folder",
      description: "New cards are created here; KanDo actions enabled for files in this folder",
      options: [
        { value: "", label: "Select a folder" },
        ...folders.map((f) => ({ value: f, label: f }))
      ],
      value: this.plugin.settings.cardsFolder,
      onChange: async (value) => {
        this.plugin.settings.cardsFolder = value;
        await this.plugin.saveSettings();
      }
    });
    const syncRightCol = syncGrid.createDiv({ cls: "vk-settings-column" });
    this.createColumnHeader(syncRightCol, "Behavior");
    this.createToggleSetting(syncRightCol, {
      label: "Auto-push on save",
      description: "Push changes to Vibe Kanban when saving files",
      value: this.plugin.settings.autoPushOnSave,
      onChange: async (value) => {
        this.plugin.settings.autoPushOnSave = value;
        await this.plugin.saveSettings();
      }
    });
    this.createToggleSetting(syncRightCol, {
      label: "Auto-sync status",
      description: "Sync card status via polling in real-time",
      value: this.plugin.settings.autoSyncStatus,
      onChange: async (value) => {
        this.plugin.settings.autoSyncStatus = value;
        await this.plugin.saveSettings();
        this.plugin.updateWebSocketConnection();
      }
    });
    const prefCard = this.createCard(wrapper, "Preferences", "settings");
    const prefContainer = prefCard.createDiv({ cls: "vk-settings-column" });
    this.createToggleSetting(prefContainer, {
      label: "Show status bar",
      description: "Display connection status in Obsidian status bar",
      value: this.plugin.settings.showStatusBar,
      onChange: async (value) => {
        this.plugin.settings.showStatusBar = value;
        await this.plugin.saveSettings();
        this.plugin.updateStatusBarVisibility();
      }
    });
    this.createToggleSetting(prefContainer, {
      label: "Open in Obsidian",
      description: "Open Vibe Kanban natively in Obsidian",
      value: this.plugin.settings.openInObsidian,
      onChange: async (value) => {
        this.plugin.settings.openInObsidian = value;
        await this.plugin.saveSettings();
      }
    });
    const advCard = this.createCard(wrapper, "Advanced", "code");
    const advContainer = advCard.createDiv({ cls: "vk-settings-column" });
    this.createToggleSetting(advContainer, {
      label: "Debug mode",
      description: "Enable verbose logging in developer console",
      value: this.plugin.settings.debug,
      onChange: async (value) => {
        this.plugin.settings.debug = value;
        await this.plugin.saveSettings();
      }
    });
  }
  // === UI Helper Methods ===
  createCard(parent, title, icon) {
    const card = parent.createDiv({ cls: "vk-card" });
    const header = card.createDiv({ cls: "vk-card-header" });
    const iconEl = header.createSpan({ cls: "vk-card-icon" });
    (0, import_obsidian2.setIcon)(iconEl, icon);
    header.createEl("h2", { text: title, cls: "vk-card-title" });
    return card;
  }
  createColumnHeader(parent, title, icon) {
    const header = parent.createDiv({ cls: "vk-column-header" });
    if (icon) {
      const iconEl = header.createSpan({ cls: "vk-column-header-icon" });
      (0, import_obsidian2.setIcon)(iconEl, icon);
    }
    header.createSpan({ text: title });
  }
  createTextInput(parent, config) {
    const container = parent.createDiv({ cls: "vk-input-group" });
    const labelId = `vk-label-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const labelEl = container.createEl("label", { text: config.label, cls: "vk-input-label" });
    labelEl.setAttribute("id", labelId);
    container.createEl("div", { text: config.description, cls: "vk-input-description" });
    const input = container.createEl("input", {
      cls: "vk-text-input",
      type: "text",
      placeholder: config.placeholder,
      value: config.value
    });
    input.setAttribute("aria-labelledby", labelId);
    input.addEventListener("input", () => config.onChange(input.value));
    return container;
  }
  createDropdownInput(parent, config) {
    const container = parent.createDiv({ cls: "vk-input-group" });
    const labelId = `vk-label-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const labelEl = container.createEl("label", { text: config.label, cls: "vk-input-label" });
    labelEl.setAttribute("id", labelId);
    container.createEl("div", { text: config.description, cls: "vk-input-description" });
    const select = container.createEl("select", { cls: "vk-dropdown" });
    select.setAttribute("aria-labelledby", labelId);
    for (const option of config.options) {
      const opt = select.createEl("option", { value: option.value, text: option.label });
      if (option.value === config.value)
        opt.selected = true;
    }
    select.addEventListener("change", () => config.onChange(select.value));
    return container;
  }
  createFolderInput(parent, config) {
    return this.createDropdownInput(parent, config);
  }
  createToggleSetting(parent, config) {
    const container = parent.createDiv({ cls: "vk-toggle-item" });
    const inputId = `vk-toggle-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const switchEl = container.createDiv({ cls: "vk-toggle-switch" });
    const input = switchEl.createEl("input", { type: "checkbox", cls: "vk-toggle-input" });
    input.checked = config.value;
    input.setAttribute("id", inputId);
    input.setAttribute("aria-describedby", `${inputId}-desc`);
    const slider = switchEl.createDiv({ cls: "vk-toggle-slider" });
    slider.setAttribute("role", "presentation");
    slider.setAttribute("tabindex", "0");
    slider.addEventListener("click", () => {
      input.checked = !input.checked;
      config.onChange(input.checked);
    });
    slider.addEventListener("keydown", (e) => {
      if (e.key === " " || e.key === "Enter") {
        e.preventDefault();
        input.checked = !input.checked;
        config.onChange(input.checked);
      }
    });
    const content = container.createDiv({ cls: "vk-toggle-content" });
    const labelEl = content.createEl("label", { text: config.label, cls: "vk-toggle-label" });
    labelEl.setAttribute("for", inputId);
    const descEl = content.createDiv({ text: config.description, cls: "vk-toggle-desc" });
    descEl.setAttribute("id", `${inputId}-desc`);
    return container;
  }
  async loadProjects() {
    try {
      this.projects = await this.plugin.api.getProjects();
      this.projectsLoadFailed = false;
    } catch (e) {
      this.projects = [];
      this.projectsLoadFailed = true;
    }
  }
  async loadProfiles() {
    try {
      const profiles = await this.plugin.api.getProfiles();
      this.executorOptions = parseExecutorProfiles(profiles);
    } catch (e) {
      this.executorOptions = [
        { executor: DEFAULT_EXECUTOR, variants: [...DEFAULT_EXECUTOR_VARIANTS] }
      ];
    }
  }
  populateVariantDropdown(selectEl) {
    if (!selectEl)
      return;
    selectEl.empty();
    const executorOption = this.executorOptions.find(
      (opt) => opt.executor === this.plugin.settings.defaultExecutor
    );
    const variants = (executorOption == null ? void 0 : executorOption.variants) || ["DEFAULT"];
    for (const variant of variants) {
      const option = selectEl.createEl("option", {
        text: variant,
        value: variant
      });
      if (variant === this.plugin.settings.defaultVariant) {
        option.selected = true;
      }
    }
    if (!variants.includes(this.plugin.settings.defaultVariant)) {
      this.plugin.settings.defaultVariant = variants.includes("DEFAULT") ? "DEFAULT" : variants[0] || "DEFAULT";
      selectEl.value = this.plugin.settings.defaultVariant;
    }
  }
  updateVariantDropdown(selectEl) {
    this.populateVariantDropdown(selectEl);
  }
  getFolders() {
    const folders = [];
    const allFiles = this.app.vault.getAllLoadedFiles();
    for (const file of allFiles) {
      if (file instanceof import_obsidian2.TFolder && file.path !== "/") {
        folders.push(file.path);
      }
    }
    return folders.sort((a, b) => a.localeCompare(b));
  }
};

// src/modals/PushModal.ts
var import_obsidian3 = require("obsidian");
var PushModal = class extends import_obsidian3.Modal {
  constructor(app, title, projects, defaultProjectId, onSubmit) {
    super(app);
    this.title = title;
    this.projects = projects;
    if (projects.length > 0) {
      this.selectedProjectId = defaultProjectId || projects[0].id;
    } else {
      this.selectedProjectId = "";
    }
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    this.scope.register([], "Escape", () => {
      this.close();
      return false;
    });
    contentEl.createEl("h2", { text: "Push to Vibe Kanban" });
    new import_obsidian3.Setting(contentEl).setName("Title").setDesc("The feature title that will be used in Vibe Kanban").addText((text) => {
      text.setValue(this.title);
      text.setDisabled(true);
    });
    new import_obsidian3.Setting(contentEl).setName("Project").setDesc("Select the Vibe Kanban project for this feature").addDropdown((dropdown) => {
      if (this.projects.length === 0) {
        dropdown.addOption("", "No projects available");
        dropdown.setDisabled(true);
      } else {
        for (const project of this.projects) {
          dropdown.addOption(project.id, project.name);
        }
        dropdown.setValue(this.selectedProjectId);
        dropdown.onChange((value) => {
          this.selectedProjectId = value;
        });
      }
    });
    contentEl.createEl("p", {
      text: "This will create a new task in Vibe Kanban with the note content as the description.",
      cls: "setting-item-description"
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
      this.close();
    });
    const pushButton = buttonContainer.createEl("button", {
      text: "Push",
      cls: "mod-cta"
    });
    pushButton.addEventListener("click", async () => {
      if (!this.selectedProjectId) {
        new import_obsidian3.Notice("Please select a project");
        return;
      }
      if (!this.projects.find((p) => p.id === this.selectedProjectId)) {
        new import_obsidian3.Notice("Invalid project selected");
        return;
      }
      pushButton.disabled = true;
      pushButton.setText("Pushing...");
      try {
        await this.onSubmit(this.selectedProjectId);
        this.close();
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        new import_obsidian3.Notice(`Failed to push: ${message}`);
        pushButton.disabled = false;
        pushButton.setText("Push");
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/ExecuteModal.ts
var import_obsidian4 = require("obsidian");
var ExecuteModal = class extends import_obsidian4.Modal {
  constructor(app, title, branches, executorOptions, defaultExecutor, defaultVariant, defaultBranch, onSubmit) {
    super(app);
    this.variantDropdownEl = null;
    this.title = title;
    this.branches = branches;
    this.executorOptions = executorOptions;
    this.selectedExecutor = defaultExecutor;
    this.selectedVariant = defaultVariant;
    this.selectedBranch = defaultBranch;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    this.scope.register([], "Escape", () => {
      this.close();
      return false;
    });
    contentEl.createEl("h2", { text: "Execute in Vibe Kanban" });
    new import_obsidian4.Setting(contentEl).setName("Feature").addText((text) => {
      text.setValue(this.title);
      text.setDisabled(true);
    });
    new import_obsidian4.Setting(contentEl).setName("Executor").setDesc("The AI agent that will work on this task").addDropdown((dropdown) => {
      for (const option of this.executorOptions) {
        dropdown.addOption(option.executor, option.executor.replace(/_/g, " "));
      }
      dropdown.setValue(this.selectedExecutor);
      dropdown.onChange((value) => {
        this.selectedExecutor = value;
        this.updateVariantDropdown();
      });
    });
    const variantSetting = new import_obsidian4.Setting(contentEl).setName("Variant").setDesc("Configuration variant for the executor");
    variantSetting.addDropdown((dropdown) => {
      this.variantDropdownEl = dropdown.selectEl;
      this.populateVariantDropdown(dropdown.selectEl);
      dropdown.onChange((value) => {
        this.selectedVariant = value;
      });
    });
    new import_obsidian4.Setting(contentEl).setName("Base Branch").setDesc("The branch to create the feature branch from").addDropdown((dropdown) => {
      const localBranches = this.branches.filter((b) => !b.is_remote);
      if (localBranches.length === 0) {
        dropdown.addOption(this.selectedBranch || "main", this.selectedBranch || "main");
        dropdown.setValue(this.selectedBranch || "main");
      } else {
        for (const branch of localBranches) {
          dropdown.addOption(branch.name, branch.name + (branch.is_current ? " (current)" : ""));
        }
        if (localBranches.some((b) => b.name === this.selectedBranch)) {
          dropdown.setValue(this.selectedBranch);
        } else {
          this.selectedBranch = localBranches[0].name;
          dropdown.setValue(this.selectedBranch);
        }
      }
      dropdown.onChange((value) => {
        this.selectedBranch = value;
      });
    });
    const warning = contentEl.createEl("p", {
      cls: "setting-item-description mod-warning"
    });
    warning.textContent = "This will start an AI agent working on this task in Vibe Kanban.";
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
      this.close();
    });
    const executeButton = buttonContainer.createEl("button", {
      text: "Execute",
      cls: "mod-cta"
    });
    executeButton.addEventListener("click", async () => {
      if (!this.selectedBranch) {
        new import_obsidian4.Notice("Please select a base branch");
        return;
      }
      executeButton.disabled = true;
      executeButton.setText("Starting...");
      try {
        const variant = this.selectedVariant === "DEFAULT" ? null : this.selectedVariant;
        await this.onSubmit(this.selectedExecutor, variant, this.selectedBranch);
        this.close();
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        new import_obsidian4.Notice(`Failed to execute: ${message}`);
        executeButton.disabled = false;
        executeButton.setText("Execute");
      }
    });
  }
  populateVariantDropdown(selectEl) {
    selectEl.empty();
    const executorOption = this.executorOptions.find(
      (opt) => opt.executor === this.selectedExecutor
    );
    if (executorOption) {
      for (const variant of executorOption.variants) {
        const option = selectEl.createEl("option", {
          text: variant,
          value: variant
        });
        if (variant === this.selectedVariant) {
          option.selected = true;
        }
      }
      if (!executorOption.variants.includes(this.selectedVariant)) {
        this.selectedVariant = executorOption.variants.includes("DEFAULT") ? "DEFAULT" : executorOption.variants[0] || "DEFAULT";
        selectEl.value = this.selectedVariant;
      }
    }
  }
  updateVariantDropdown() {
    if (this.variantDropdownEl) {
      this.populateVariantDropdown(this.variantDropdownEl);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/StatusModal.ts
var import_obsidian5 = require("obsidian");
var StatusModal = class extends import_obsidian5.Modal {
  constructor(app, task, attempts, vkUrl, projectId, onRefresh) {
    super(app);
    this.task = task;
    this.attempts = attempts;
    this.vkUrl = vkUrl;
    this.projectId = projectId;
    this.onRefresh = onRefresh;
  }
  onOpen() {
    const { contentEl } = this;
    this.scope.register([], "Escape", () => {
      this.close();
      return false;
    });
    contentEl.createEl("h2", { text: "Execution Status" });
    new import_obsidian5.Setting(contentEl).setName("Task").addText((text) => {
      text.setValue(this.task.title);
      text.setDisabled(true);
    });
    const statusSetting = new import_obsidian5.Setting(contentEl).setName("Status");
    const statusEl = statusSetting.controlEl.createEl("span", {
      cls: `vk-status vk-status-${this.task.status}`
    });
    const statusText = this.formatStatus(this.task.status);
    statusEl.textContent = `${this.getStatusIcon(this.task.status)} ${statusText}`;
    statusEl.setAttribute("aria-label", `Status: ${statusText}`);
    if (this.attempts.length > 0) {
      const latestAttempt = this.attempts[this.attempts.length - 1];
      contentEl.createEl("h3", { text: "Latest Attempt" });
      new import_obsidian5.Setting(contentEl).setName("Executor").addText((text) => {
        text.setValue(latestAttempt.executor.replace(/_/g, " "));
        text.setDisabled(true);
      });
      new import_obsidian5.Setting(contentEl).setName("Branch").addText((text) => {
        text.setValue(latestAttempt.branch);
        text.setDisabled(true);
      });
      new import_obsidian5.Setting(contentEl).setName("Target Branch").addText((text) => {
        text.setValue(latestAttempt.target_branch);
        text.setDisabled(true);
      });
      new import_obsidian5.Setting(contentEl).setName("Started").addText((text) => {
        const date = new Date(latestAttempt.created_at);
        const timeStr = isNaN(date.getTime()) ? "Unknown" : this.formatRelativeTime(date);
        text.setValue(timeStr);
        text.setDisabled(true);
      });
      if (this.attempts.length > 1) {
        contentEl.createEl("p", {
          text: `${this.attempts.length - 1} previous attempt(s)`,
          cls: "setting-item-description"
        });
      }
    } else {
      contentEl.createEl("p", {
        text: "No execution attempts yet.",
        cls: "setting-item-description"
      });
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const openButton = buttonContainer.createEl("button", { text: "View in Vibe Kanban" });
    openButton.addEventListener("click", () => {
      if (!this.vkUrl || !this.projectId || !this.task.id) {
        new import_obsidian5.Notice("Missing URL or project information");
        return;
      }
      const baseUrl = this.vkUrl.replace(/\/+$/, "");
      const url = `${baseUrl}/projects/${encodeURIComponent(this.projectId)}/tasks/${encodeURIComponent(this.task.id)}`;
      window.open(url, "_blank");
    });
    const refreshButton = buttonContainer.createEl("button", { text: "Refresh" });
    refreshButton.addEventListener("click", async () => {
      refreshButton.disabled = true;
      refreshButton.setText("Refreshing...");
      try {
        const result = await this.onRefresh();
        this.task = result.task;
        this.attempts = result.attempts;
        this.contentEl.empty();
        this.onOpen();
        new import_obsidian5.Notice("Status refreshed");
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        new import_obsidian5.Notice(`Failed to refresh: ${message}`);
        refreshButton.disabled = false;
        refreshButton.setText("Refresh");
      }
    });
    buttonContainer.createEl("button", { text: "Close", cls: "mod-cta" }).addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  getStatusIcon(status) {
    switch (status) {
      case "notsynced":
        return "\u25C7";
      case "todo":
        return "\u25CB";
      case "inprogress":
        return "\u25D0";
      case "inreview":
        return "\u25D1";
      case "done":
        return "\u25CF";
      case "cancelled":
        return "\u2715";
      case "deleted":
        return "\u2298";
      default:
        return "\u25CB";
    }
  }
  formatStatus(status) {
    switch (status) {
      case "notsynced":
        return "Not Synced";
      case "todo":
        return "To Do";
      case "inprogress":
        return "In Progress";
      case "inreview":
        return "In Review";
      case "done":
        return "Done";
      case "cancelled":
        return "Cancelled";
      case "deleted":
        return "Deleted";
      default:
        return status;
    }
  }
  formatRelativeTime(date) {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 6e4);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    if (diffMins < 1)
      return "Just now";
    if (diffMins < 60)
      return `${diffMins} minute${diffMins === 1 ? "" : "s"} ago`;
    if (diffHours < 24)
      return `${diffHours} hour${diffHours === 1 ? "" : "s"} ago`;
    return `${diffDays} day${diffDays === 1 ? "" : "s"} ago`;
  }
};

// src/modals/CreateCardModal.ts
var import_obsidian6 = require("obsidian");
var CreateCardModal = class extends import_obsidian6.Modal {
  constructor(app, projects, defaultProjectId, defaultTitle) {
    super(app);
    this.resolvePromise = null;
    this.projects = projects;
    this.defaultProjectId = defaultProjectId;
    this.defaultTitle = defaultTitle;
    this.title = "";
    this.description = "";
    this.projects = [...projects].sort((a, b) => {
      if (a.id === defaultProjectId)
        return -1;
      if (b.id === defaultProjectId)
        return 1;
      return a.name.localeCompare(b.name);
    });
    if (this.projects.length > 0) {
      this.selectedProject = this.projects.find((p) => p.id === defaultProjectId) || this.projects[0];
    } else {
      this.selectedProject = null;
    }
  }
  async openAndWait() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      this.open();
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("vk-create-card-modal");
    contentEl.createEl("h2", { text: "New KanDo card" });
    if (this.projects.length === 0) {
      contentEl.createEl("p", {
        text: "No projects available. Please check your Vibe Kanban connection.",
        cls: "setting-item-description mod-warning"
      });
      const buttonContainer2 = contentEl.createDiv({ cls: "modal-button-container" });
      buttonContainer2.createEl("button", { text: "Close", cls: "mod-cta" }).addEventListener("click", () => {
        this.close();
      });
      return;
    }
    new import_obsidian6.Setting(contentEl).setName("Project").addDropdown((dropdown) => {
      var _a;
      for (const project of this.projects) {
        const label = project.id === this.defaultProjectId ? `${project.name} (default)` : project.name;
        dropdown.addOption(project.id, label);
      }
      dropdown.setValue(((_a = this.selectedProject) == null ? void 0 : _a.id) || "");
      dropdown.onChange((value) => {
        this.selectedProject = this.projects.find((p) => p.id === value) || this.projects[0];
      });
    });
    new import_obsidian6.Setting(contentEl).setName("Title").addText((text) => {
      text.setPlaceholder("Card title");
      text.onChange((value) => {
        this.title = value;
      });
      setTimeout(() => text.inputEl.focus(), 50);
    });
    new import_obsidian6.Setting(contentEl).setName("Prompt").setDesc("Optional - press Cmd/Ctrl+Enter to submit");
    const textAreaContainer = contentEl.createDiv({ cls: "vk-textarea-container" });
    const textArea = new import_obsidian6.TextAreaComponent(textAreaContainer);
    textArea.setPlaceholder("Prompt details here...");
    textArea.onChange((value) => {
      this.description = value;
    });
    textArea.inputEl.rows = 6;
    textArea.inputEl.addClass("vk-description-textarea");
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
      this.close();
    });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => {
      if (!this.title.trim()) {
        new import_obsidian6.Notice("Please enter a title");
        return;
      }
      if (!this.selectedProject) {
        new import_obsidian6.Notice("Please select a project");
        return;
      }
      if (this.resolvePromise) {
        this.resolvePromise({
          project: this.selectedProject,
          title: this.title.trim(),
          description: this.description.trim()
        });
        this.resolvePromise = null;
      }
      this.close();
    });
    contentEl.addEventListener("keydown", (e) => {
      var _a;
      const isTextArea = ((_a = document.activeElement) == null ? void 0 : _a.tagName) === "TEXTAREA";
      const isModifiedEnter = e.key === "Enter" && (e.metaKey || e.ctrlKey);
      const isPlainEnter = e.key === "Enter" && !e.shiftKey && !isTextArea;
      if (isModifiedEnter || isPlainEnter) {
        e.preventDefault();
        createButton.click();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.resolvePromise) {
      this.resolvePromise(null);
      this.resolvePromise = null;
    }
  }
};

// src/websocket.ts
var import_obsidian7 = require("obsidian");
var VKStatusPoller = class {
  constructor() {
    this.pollTimer = null;
    this.pollInterval = 5e3;
    // 5 seconds
    this.baseBackoff = 5e3;
    // Base backoff for errors
    this.maxBackoff = 6e4;
    // Max backoff (1 minute)
    this.currentBackoff = 5e3;
    this.consecutiveErrors = 0;
    this.isPolling = false;
    this.onTaskUpdate = null;
    this.vkUrl = "";
    this.projectIds = /* @__PURE__ */ new Set();
    this.lastKnownStates = /* @__PURE__ */ new Map();
    // taskId -> "status:executing" combined state
    this.taskProjectMap = /* @__PURE__ */ new Map();
    // taskId -> projectId (for cleanup)
    this.debug = false;
    this.maxTrackedTasks = 1e3;
    // Prevent unbounded memory growth
    this.activeTaskIds = /* @__PURE__ */ new Set();
  }
  // Tasks actively being tracked (from files)
  start(vkUrl, projectIds, onTaskUpdate, debug = false) {
    if (this.isPolling) {
      return;
    }
    this.vkUrl = vkUrl.replace(/\/$/, "");
    this.projectIds = new Set(projectIds.filter((id) => id));
    this.onTaskUpdate = onTaskUpdate;
    this.debug = debug;
    this.isPolling = true;
    if (this.debug) {
      console.log("[KanDo] Poller starting for projects:", Array.from(this.projectIds));
    }
    if (this.projectIds.size === 0) {
      if (this.debug) {
        console.log("[KanDo] No projects to poll");
      }
      return;
    }
    this.poll();
  }
  /**
   * Add a project to poll (e.g., when a new task is created in a different project)
   */
  addProject(projectId) {
    if (projectId && !this.projectIds.has(projectId)) {
      this.projectIds.add(projectId);
      if (this.debug) {
        console.log("[KanDo] Added project to poll:", projectId);
      }
    }
  }
  /**
   * Mark a task as actively tracked (associated with a file)
   */
  trackTask(taskId) {
    this.activeTaskIds.add(taskId);
  }
  /**
   * Remove a task from active tracking (file deleted or task completed)
   */
  untrackTask(taskId) {
    this.activeTaskIds.delete(taskId);
    this.lastKnownStates.delete(taskId);
    this.taskProjectMap.delete(taskId);
  }
  /**
   * Clean up tasks that have reached terminal states and are no longer active
   */
  cleanupTerminalTasks() {
    const terminalStatuses = /* @__PURE__ */ new Set(["done", "cancelled", "deleted"]);
    for (const [taskId, state] of this.lastKnownStates.entries()) {
      const status = state.split(":")[0];
      if (terminalStatuses.has(status) && !this.activeTaskIds.has(taskId)) {
        this.lastKnownStates.delete(taskId);
        this.taskProjectMap.delete(taskId);
        if (this.debug) {
          console.log("[KanDo] Cleaned up terminal task:", taskId, state);
        }
      }
    }
  }
  async poll() {
    if (!this.isPolling)
      return;
    const baseUrl = this.vkUrl.replace(/\/+$/, "");
    let hasError = false;
    for (const projectId of this.projectIds) {
      if (!this.isPolling)
        return;
      try {
        const url = `${baseUrl}/api/tasks?project_id=${encodeURIComponent(projectId)}`;
        if (this.debug) {
          console.log("[KanDo] Polling:", url);
        }
        const response = await (0, import_obsidian7.requestUrl)({
          url,
          method: "GET"
        });
        if (response.status === 200) {
          const responseData = response.json;
          const tasks = (responseData == null ? void 0 : responseData.data) || [];
          if (this.debug) {
            console.log("[KanDo] Poll response for project", projectId, ":", tasks.length, "tasks");
          }
          const currentTaskIds = new Set(tasks.map((t) => t.id));
          for (const [taskId, taskProjectId] of this.taskProjectMap.entries()) {
            if (taskProjectId === projectId && !currentTaskIds.has(taskId)) {
              const lastStatus = this.lastKnownStates.get(taskId);
              if (lastStatus && lastStatus !== "deleted") {
                if (this.debug) {
                  console.log("[KanDo] Task deleted:", taskId);
                }
                if (this.onTaskUpdate) {
                  this.onTaskUpdate({
                    id: taskId,
                    project_id: projectId,
                    title: "",
                    description: null,
                    status: "deleted",
                    parent_task_attempt: null,
                    shared_task_id: null,
                    created_at: "",
                    updated_at: "",
                    has_in_progress_attempt: false,
                    has_merged_attempt: false,
                    last_attempt_failed: false,
                    executor: null
                  });
                }
                this.lastKnownStates.delete(taskId);
                this.taskProjectMap.delete(taskId);
              }
            }
          }
          for (const task of tasks) {
            const currentState = `${task.status}:${task.has_in_progress_attempt}`;
            const lastState = this.lastKnownStates.get(task.id);
            if (lastState !== void 0 && lastState !== currentState) {
              if (this.debug) {
                console.log("[KanDo] Task state changed:", task.id, lastState, "->", currentState);
              }
              if (this.onTaskUpdate) {
                this.onTaskUpdate(task);
              }
            }
            this.lastKnownStates.set(task.id, currentState);
            this.taskProjectMap.set(task.id, projectId);
          }
          this.cleanupTerminalTasks();
          if (this.lastKnownStates.size > this.maxTrackedTasks) {
            const entriesToRemove = this.lastKnownStates.size - this.maxTrackedTasks;
            const iterator = this.lastKnownStates.keys();
            let removed = 0;
            for (const key of iterator) {
              if (removed >= entriesToRemove)
                break;
              if (!this.activeTaskIds.has(key)) {
                this.lastKnownStates.delete(key);
                this.taskProjectMap.delete(key);
                removed++;
              }
            }
          }
        }
      } catch (error) {
        hasError = true;
        if (this.debug) {
          console.error("[KanDo] Poll error for project", projectId, ":", error);
        }
      }
    }
    if (hasError) {
      this.consecutiveErrors++;
      this.currentBackoff = Math.min(
        this.baseBackoff * Math.pow(2, this.consecutiveErrors - 1),
        this.maxBackoff
      );
      if (this.debug) {
        console.log(`[KanDo] Poll error, backing off for ${this.currentBackoff}ms`);
      }
    } else {
      this.consecutiveErrors = 0;
      this.currentBackoff = this.pollInterval;
    }
    if (this.isPolling) {
      this.pollTimer = window.setTimeout(() => this.poll(), this.currentBackoff);
    }
  }
  stop() {
    this.isPolling = false;
    if (this.pollTimer) {
      window.clearTimeout(this.pollTimer);
      this.pollTimer = null;
    }
    this.lastKnownStates.clear();
    this.taskProjectMap.clear();
    this.projectIds.clear();
    this.activeTaskIds.clear();
    this.consecutiveErrors = 0;
    this.currentBackoff = this.pollInterval;
  }
  isRunning() {
    return this.isPolling;
  }
  // Initialize known state without triggering updates
  setKnownState(taskId, status, executing = false) {
    this.lastKnownStates.set(taskId, `${status}:${executing}`);
  }
};

// src/views/VibeKanbanView.ts
var import_obsidian8 = require("obsidian");
var VIBE_KANBAN_VIEW_TYPE = "vibe-kanban-view";
var TRUSTED_HOSTS = [
  "localhost",
  "127.0.0.1",
  "0.0.0.0",
  "::1"
];
function isUrlTrusted(url) {
  try {
    const parsed = new URL(url);
    const host = parsed.hostname.toLowerCase();
    const trusted = TRUSTED_HOSTS.some(
      (trustedHost) => host === trustedHost || host.endsWith(`.${trustedHost}`)
    );
    return { trusted, host };
  } catch (e) {
    return { trusted: false, host: "invalid" };
  }
}
var VibeKanbanView = class extends import_obsidian8.ItemView {
  constructor(leaf) {
    super(leaf);
    this.vkUrl = "";
    this.currentPath = "";
    this.webview = null;
    this.isReady = false;
    this.userAcknowledgedUntrustedUrl = false;
  }
  /**
   * Set the VK URL and optional path, then load
   */
  setUrl(vkUrl, path = "") {
    this.vkUrl = vkUrl;
    this.currentPath = path;
    if (this.isReady) {
      this.loadWebview();
    }
  }
  /**
   * Called by Obsidian when view state is set
   */
  async setState(state, result) {
    if (state.vkUrl) {
      this.vkUrl = state.vkUrl;
    }
    if (state.path) {
      this.currentPath = state.path;
    }
    await super.setState(state, result);
    if (this.isReady && this.vkUrl) {
      this.loadWebview();
    }
  }
  /**
   * Get the current view state
   */
  getState() {
    return {
      vkUrl: this.vkUrl,
      path: this.currentPath
    };
  }
  getViewType() {
    return VIBE_KANBAN_VIEW_TYPE;
  }
  getDisplayText() {
    return "KanDo";
  }
  getIcon() {
    return "kanban";
  }
  async onOpen() {
    this.contentEl.empty();
    this.contentEl.addClass("vk-view-container");
    this.contentEl.style.padding = "0";
    this.contentEl.style.overflow = "hidden";
    this.isReady = true;
    if (this.vkUrl) {
      this.loadWebview();
    } else {
      this.contentEl.createEl("div", {
        cls: "vk-loading",
        text: "Loading KanDo..."
      });
    }
  }
  /**
   * Create and load the webview with the current URL
   */
  loadWebview() {
    if (!this.vkUrl)
      return;
    this.contentEl.empty();
    const { trusted, host } = isUrlTrusted(this.vkUrl);
    if (!trusted && !this.userAcknowledgedUntrustedUrl) {
      const warningEl = this.contentEl.createDiv({ cls: "vk-security-warning" });
      warningEl.createEl("h3", { text: "Security Warning" });
      warningEl.createEl("p", {
        text: `The URL "${host}" is not a localhost address. Loading external content in an embedded webview with disabled security could expose your system to risks.`
      });
      warningEl.createEl("p", {
        text: "Only proceed if you trust this URL and understand the risks.",
        cls: "vk-warning-hint"
      });
      const buttonContainer = warningEl.createDiv({ cls: "vk-warning-buttons" });
      buttonContainer.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
        this.leaf.detach();
      });
      buttonContainer.createEl("button", { text: "Load Anyway", cls: "mod-warning" }).addEventListener("click", () => {
        this.userAcknowledgedUntrustedUrl = true;
        new import_obsidian8.Notice("Loading untrusted URL - use caution");
        this.loadWebview();
      });
      return;
    }
    const baseUrl = this.vkUrl.replace(/\/+$/, "");
    const path = this.currentPath.startsWith("/") ? this.currentPath : `/${this.currentPath}`;
    const fullUrl = this.currentPath ? `${baseUrl}${path}` : baseUrl;
    const webview = document.createElement("webview");
    webview.setAttribute("src", fullUrl);
    webview.setAttribute("partition", "persist:kando");
    webview.setAttribute("disablewebsecurity", "true");
    webview.setAttribute("allowpopups", "true");
    webview.classList.add("vk-webview");
    webview.style.width = "100%";
    webview.style.height = "100%";
    webview.style.border = "none";
    this.webview = webview;
    this.contentEl.appendChild(webview);
    webview.addEventListener("dom-ready", () => {
      window.dispatchEvent(new Event("resize"));
    });
    webview.addEventListener("did-fail-load", (event) => {
      if (event.errorCode && event.errorCode !== -3) {
        this.contentEl.empty();
        this.contentEl.createEl("div", {
          cls: "vk-error",
          text: `Failed to load Vibe Kanban: ${event.errorDescription || "Unknown error"}`
        });
        this.contentEl.createEl("div", {
          cls: "vk-error-hint",
          text: `Make sure Vibe Kanban is running at ${this.vkUrl}`
        });
      }
    });
  }
  async onClose() {
    this.webview = null;
    this.isReady = false;
  }
  /**
   * Navigate to a specific path within VK
   */
  navigateTo(path) {
    this.currentPath = path;
    if (this.webview && this.vkUrl) {
      const baseUrl = this.vkUrl.replace(/\/+$/, "");
      const normalizedPath = path.startsWith("/") ? path : `/${path}`;
      const fullUrl = `${baseUrl}${normalizedPath}`;
      this.webview.src = fullUrl;
    }
  }
  /**
   * Reload the webview
   */
  reload() {
    if (this.webview) {
      this.webview.reload();
    }
  }
};

// main.ts
var VibeKanbanPlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarItem = null;
    this.statusBarClickHandler = null;
    this.toolbarButtons = /* @__PURE__ */ new WeakMap();
    this.fileExplorerButton = null;
    this.statusPoller = null;
    this.taskIdToFileIndex = /* @__PURE__ */ new Map();
    // taskId -> filePath
    this.filesBeingUpdated = /* @__PURE__ */ new Set();
  }
  // Prevent auto-push during programmatic updates (per-file)
  async onload() {
    await this.loadSettings();
    (0, import_obsidian9.addIcon)("kanban-plus", '<g stroke="currentColor" stroke-width="10" stroke-linecap="round" stroke-linejoin="round" fill="none"><path d="M21 12.5v58"/><path d="M50 12.5v33"/><path d="M79 12.5v38"/><path d="M67 79h25"/><path d="M79 67v25"/></g>');
    (0, import_obsidian9.addIcon)("kanban-upload", '<g stroke="currentColor" stroke-width="10" stroke-linecap="round" stroke-linejoin="round" fill="none"><path d="M17 15v50"/><path d="M40 15v25"/><path d="M63 15v30"/><path d="M79 88v-38"/><path d="M64 65l15-15 15 15"/></g>');
    (0, import_obsidian9.addIcon)("kanban-play", '<g stroke="currentColor" stroke-width="8" stroke-linecap="round" stroke-linejoin="round" fill="none"><path d="M21 12.5v58"/><path d="M50 12.5v33"/><path d="M79 12.5v38"/></g><polygon points="62.5 67 87.5 79 62.5 92" fill="currentColor" stroke="currentColor" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>');
    this.api = new VKApiClient(this.settings.vkUrl);
    this.frontmatter = new FrontmatterManager(this.app);
    const ribbonIcon = this.addRibbonIcon("kanban", "KanDo", (evt) => {
      this.openVibeKanbanView();
    });
    this.registerDomEvent(ribbonIcon, "contextmenu", (evt) => {
      evt.preventDefault();
      this.showRibbonMenu(evt);
    });
    if (this.settings.showStatusBar) {
      this.createStatusBarItem();
    }
    this.addCommand({
      id: "push-card",
      name: "Push Feature",
      checkCallback: (checking) => {
        const file = this.getActiveFile();
        if (file && this.isInCardsFolder(file)) {
          if (!checking) {
            this.pushCard(file);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "execute-card",
      name: "Add and Execute",
      checkCallback: (checking) => {
        const file = this.getActiveFile();
        if (file && this.isInCardsFolder(file)) {
          if (!checking) {
            this.executeCard(file);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "pull-status",
      name: "Pull Status",
      checkCallback: (checking) => {
        const file = this.getActiveFile();
        if (file && this.isInCardsFolder(file)) {
          if (!checking) {
            this.pullStatus(file);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "open-in-vk",
      name: "View in Vibe Kanban",
      checkCallback: (checking) => {
        const file = this.getActiveFile();
        if (file && this.isInCardsFolder(file)) {
          if (!checking) {
            this.openInVK(file);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "create-card",
      name: "Create New Feature",
      callback: () => {
        this.createNewCard();
      }
    });
    this.addSettingTab(new VKSettingTab(this.app, this));
    this.registerView(
      VIBE_KANBAN_VIEW_TYPE,
      (leaf) => new VibeKanbanView(leaf)
    );
    this.addCommand({
      id: "open-vibe-kanban-view",
      name: "Open Vibe Kanban",
      callback: () => {
        this.openVibeKanbanView();
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (file) {
          this.updateStatusBar(file);
          this.updateToolbarForFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (file instanceof import_obsidian9.TFile && this.isInCardsFolder(file)) {
          this.updateStatusBar(file);
          this.updateToolbarForFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        const file = this.getActiveFile();
        if (file) {
          this.updateStatusBar(file);
          this.updateToolbarForFile(file);
        }
        if ((leaf == null ? void 0 : leaf.view) instanceof import_obsidian9.MarkdownView) {
          this.addToolbarToView(leaf.view);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.app.workspace.iterateAllLeaves((leaf) => {
          if (leaf.view instanceof import_obsidian9.MarkdownView) {
            this.addToolbarToView(leaf.view);
          }
        });
        this.addFileExplorerButton();
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian9.TFolder) {
          menu.addItem((item) => {
            item.setTitle("New KanDo card").setIcon("list-plus").onClick(() => {
              this.createNewCard(file.path);
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        if (!(file instanceof import_obsidian9.TFile))
          return;
        if (this.filesBeingUpdated.has(file.path)) {
          return;
        }
        if (this.settings.autoPushOnSave && this.isInCardsFolder(file)) {
          const isSynced = await this.frontmatter.isSynced(file);
          if (isSynced) {
            await this.pushCardQuiet(file);
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (!(file instanceof import_obsidian9.TFile))
          return;
        for (const [taskId, filePath] of Array.from(this.taskIdToFileIndex.entries())) {
          if (filePath === oldPath) {
            this.taskIdToFileIndex.set(taskId, file.path);
            if (this.settings.debug) {
              console.log(`[KanDo] Updated task index: ${taskId} -> ${file.path}`);
            }
            break;
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (!(file instanceof import_obsidian9.TFile))
          return;
        for (const [taskId, filePath] of Array.from(this.taskIdToFileIndex.entries())) {
          if (filePath === file.path) {
            this.taskIdToFileIndex.delete(taskId);
            if (this.statusPoller) {
              this.statusPoller.untrackTask(taskId);
            }
            if (this.settings.debug) {
              console.log(`[KanDo] Removed task from index: ${taskId}`);
            }
            break;
          }
        }
      })
    );
    this.app.workspace.onLayoutReady(async () => {
      this.app.workspace.iterateAllLeaves((leaf) => {
        if (leaf.view instanceof import_obsidian9.MarkdownView) {
          this.addToolbarToView(leaf.view);
        }
      });
      this.addFileExplorerButton();
      await this.buildTaskIndex();
      this.updateWebSocketConnection();
    });
  }
  onunload() {
    this.removeStatusBarItem();
    this.removeFileExplorerButton();
    if (this.statusPoller) {
      this.statusPoller.stop();
      this.statusPoller = null;
    }
  }
  removeFileExplorerButton() {
    const explorers = this.app.workspace.getLeavesOfType("file-explorer");
    explorers.forEach((explorer) => {
      const button = explorer.view.containerEl.querySelector(".vk-explorer-new-button");
      if (button)
        button.remove();
    });
    this.fileExplorerButton = null;
  }
  addToolbarToView(view) {
    const leaf = view.leaf;
    if (this.toolbarButtons.has(leaf)) {
      return;
    }
    const openButton = view.addAction("external-link", "View in Vibe Kanban", () => {
      if (view.file)
        this.handleOpenClick(view.file);
    });
    openButton.addClass("vk-open");
    const executeButton = view.addAction("kanban-play", "Add and Execute", () => {
      if (view.file)
        this.handleExecuteClick(view.file);
    });
    executeButton.addClass("vk-execute");
    const addButton = view.addAction("kanban-upload", "Push to To Do", () => {
      if (view.file)
        this.handleAddClick(view.file);
    });
    addButton.addClass("vk-add");
    this.toolbarButtons.set(leaf, {
      add: addButton,
      execute: executeButton,
      open: openButton
    });
    if (view.file) {
      this.updateToolbarButtons(view.file);
    }
  }
  addFileExplorerButton() {
    const explorers = this.app.workspace.getLeavesOfType("file-explorer");
    explorers.forEach((explorer) => {
      this.addButtonToExplorer(explorer);
    });
  }
  addButtonToExplorer(explorer) {
    const container = explorer.view.containerEl;
    const navContainer = container.querySelector("div.nav-buttons-container");
    if (!navContainer)
      return;
    if (navContainer.querySelector(".vk-explorer-new-button"))
      return;
    const button = document.createElement("div");
    button.className = "clickable-icon nav-action-button vk-explorer-new-button";
    button.setAttribute("aria-label", "New KanDo card");
    (0, import_obsidian9.setIcon)(button, "kanban-plus");
    this.registerDomEvent(button, "click", () => {
      this.createNewCard();
    });
    navContainer.appendChild(button);
    this.fileExplorerButton = button;
  }
  async updateToolbarForFile(file) {
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      if (leaf.view instanceof import_obsidian9.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === file.path) {
        this.updateToolbarButtons(file);
      }
    });
  }
  async updateToolbarButtons(file) {
    const matchingLeaves = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      if (leaf.view instanceof import_obsidian9.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === file.path) {
        matchingLeaves.push(leaf);
      }
    });
    for (const leaf of matchingLeaves) {
      const buttons = this.toolbarButtons.get(leaf);
      if (!buttons)
        continue;
      const { add, execute, open } = buttons;
      add.removeClass("vk-hidden", "vk-disabled");
      execute.removeClass("vk-hidden", "vk-disabled", "vk-executing");
      open.removeClass("vk-hidden", "vk-disabled");
      if (!this.isInCardsFolder(file)) {
        add.addClass("vk-hidden");
        execute.addClass("vk-hidden");
        open.addClass("vk-hidden");
        continue;
      }
      const isSynced = await this.frontmatter.isSynced(file);
      const fm = isSynced ? await this.frontmatter.read(file) : null;
      const status = (fm == null ? void 0 : fm.vk_status) || null;
      const isExecuting = (fm == null ? void 0 : fm.vk_executing) === true;
      if (!isSynced) {
        (0, import_obsidian9.setIcon)(add, "kanban-upload");
        add.setAttribute("aria-label", "Push to To Do");
        execute.setAttribute("aria-label", "Add and Execute");
        open.addClass("vk-hidden");
      } else {
        (0, import_obsidian9.setIcon)(add, "refresh-cw");
        add.setAttribute("aria-label", "Push changes");
        if (isExecuting) {
          execute.addClass("vk-executing", "vk-disabled");
          execute.setAttribute("aria-label", "Executing...");
          add.addClass("vk-hidden");
          open.setAttribute("aria-label", "View Task");
        } else if (status === "inreview" || status === "done") {
          execute.addClass("vk-hidden");
          add.addClass("vk-hidden");
          open.setAttribute("aria-label", "View Task");
        } else {
          execute.setAttribute("aria-label", "Add and Execute");
          open.setAttribute("aria-label", "View in Vibe Kanban");
        }
      }
    }
  }
  // Handler for Push to To Do button
  async handleAddClick(file) {
    if (!this.isInCardsFolder(file)) {
      new import_obsidian9.Notice("Not a card file");
      return;
    }
    await this.pushCard(file);
  }
  // Handler for Execute button
  async handleExecuteClick(file) {
    if (!this.isInCardsFolder(file)) {
      new import_obsidian9.Notice("Not a card file");
      return;
    }
    const isSynced = await this.frontmatter.isSynced(file);
    const status = isSynced ? await this.frontmatter.getStatus(file) : null;
    if (status === "inprogress" || status === "inreview") {
      return;
    }
    if (!isSynced) {
      await this.pushCardWithCallback(file, async () => {
        await this.executeCard(file);
      });
    } else {
      await this.executeCard(file);
    }
  }
  // Handler for Open in VK button
  async handleOpenClick(file) {
    if (!this.isInCardsFolder(file)) {
      new import_obsidian9.Notice("Not a card file");
      return;
    }
    const fm = await this.frontmatter.read(file);
    if (!fm.vk_task_id) {
      new import_obsidian9.Notice("Card not synced with Vibe Kanban");
      return;
    }
    const status = fm.vk_status;
    const baseUrl = this.settings.vkUrl.replace(/\/+$/, "");
    if ((status === "inprogress" || status === "inreview") && fm.vk_project_id) {
      const diffsPath = `/projects/${fm.vk_project_id}/tasks/${fm.vk_task_id}/attempts/latest?view=diffs`;
      if (this.settings.openInObsidian) {
        await this.openVibeKanbanView(diffsPath);
      } else {
        window.open(`${baseUrl}${diffsPath}`, "_blank");
      }
    } else if (fm.vk_project_id) {
      const taskPath = `/projects/${fm.vk_project_id}/tasks/${fm.vk_task_id}`;
      if (this.settings.openInObsidian) {
        await this.openVibeKanbanView(taskPath);
      } else {
        window.open(`${baseUrl}${taskPath}`, "_blank");
      }
    } else {
      new import_obsidian9.Notice("Missing project ID - cannot open task");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  createStatusBarItem() {
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.addClass("vk-status-bar");
    const iconEl = this.statusBarItem.createSpan({ cls: "vk-status-bar-icon" });
    (0, import_obsidian9.setIcon)(iconEl, "kanban");
    this.statusBarItem.createSpan({ cls: "vk-status-bar-text", text: "\u2014" });
    this.statusBarClickHandler = () => this.pullStatus();
    this.statusBarItem.addEventListener("click", this.statusBarClickHandler);
  }
  removeStatusBarItem() {
    if (this.statusBarItem) {
      if (this.statusBarClickHandler) {
        this.statusBarItem.removeEventListener("click", this.statusBarClickHandler);
        this.statusBarClickHandler = null;
      }
      this.statusBarItem.remove();
      this.statusBarItem = null;
    }
  }
  updateStatusBarVisibility() {
    if (this.settings.showStatusBar && !this.statusBarItem) {
      this.createStatusBarItem();
      const file = this.getActiveFile();
      if (file) {
        this.updateStatusBar(file);
      }
    } else if (!this.settings.showStatusBar && this.statusBarItem) {
      this.removeStatusBarItem();
    }
  }
  async updateWebSocketConnection() {
    if (this.statusPoller) {
      this.statusPoller.stop();
      this.statusPoller = null;
    }
    if (!this.settings.autoSyncStatus) {
      return;
    }
    this.statusPoller = new VKStatusPoller();
    const projectIds = /* @__PURE__ */ new Set();
    const statusPromises = [];
    for (const [taskId, filePath] of this.taskIdToFileIndex.entries()) {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian9.TFile) {
        const promise = this.frontmatter.read(file).then((fm) => {
          var _a;
          if (fm.vk_project_id) {
            projectIds.add(fm.vk_project_id);
          }
          if (this.statusPoller) {
            this.statusPoller.trackTask(taskId);
            if (fm.vk_status) {
              this.statusPoller.setKnownState(taskId, fm.vk_status, (_a = fm.vk_executing) != null ? _a : false);
            }
          }
        });
        statusPromises.push(promise);
      }
    }
    await Promise.all(statusPromises);
    if (this.settings.defaultProjectId) {
      projectIds.add(this.settings.defaultProjectId);
    }
    if (projectIds.size === 0) {
      if (this.settings.debug) {
        console.log("[KanDo] No projects to poll - skipping poller start");
      }
      return;
    }
    this.statusPoller.start(
      this.settings.vkUrl,
      Array.from(projectIds),
      (task) => this.handleTaskUpdate(task),
      this.settings.debug
    );
  }
  async handleTaskUpdate(task) {
    const filePath = this.taskIdToFileIndex.get(task.id);
    if (!filePath) {
      return;
    }
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian9.TFile))
      return;
    this.filesBeingUpdated.add(file.path);
    try {
      await this.frontmatter.update(file, {
        vk_status: task.status,
        vk_executing: task.has_in_progress_attempt,
        vk_last_synced: new Date().toISOString()
      });
      await this.updateStatusBar(file);
      await this.updateToolbarForFile(file);
      if (task.status === "done") {
        new import_obsidian9.Notice(`KanDo: "${task.title}" completed`);
      } else if (task.status === "deleted") {
        const fm = await this.frontmatter.read(file);
        const title = fm.title || file.basename;
        new import_obsidian9.Notice(`KanDo: "${title}" deleted`);
      }
    } catch (error) {
      if (this.settings.debug) {
        console.error("[KanDo] Error handling task update:", error);
      }
    } finally {
      this.filesBeingUpdated.delete(file.path);
    }
  }
  async buildTaskIndex() {
    this.taskIdToFileIndex.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (!this.isInCardsFolder(file)) {
        continue;
      }
      try {
        const fm = await this.frontmatter.read(file);
        if (fm.vk_task_id) {
          this.taskIdToFileIndex.set(fm.vk_task_id, file.path);
          if (this.statusPoller) {
            this.statusPoller.trackTask(fm.vk_task_id);
          }
        }
      } catch (error) {
        if (error instanceof Error && !error.message.includes("frontmatter")) {
          console.error(`KanDo: Error reading ${file.path}:`, error.message);
        }
      }
    }
  }
  // Call this when a file is synced to update the index
  updateTaskIndex(taskId, filePath) {
    this.taskIdToFileIndex.set(taskId, filePath);
  }
  getActiveFile() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
    return (view == null ? void 0 : view.file) || null;
  }
  isInCardsFolder(file) {
    var _a;
    if (!this.settings.cardsFolder) {
      return true;
    }
    const folder = this.settings.cardsFolder.replace(/^\/|\/$/g, "");
    if (!folder) {
      return true;
    }
    const filePath = file.path;
    const parentPath = ((_a = file.parent) == null ? void 0 : _a.path) || "";
    return filePath.startsWith(folder + "/") || parentPath === folder || parentPath.startsWith(folder + "/");
  }
  async updateStatusBar(file) {
    if (!this.statusBarItem)
      return;
    const textEl = this.statusBarItem.querySelector(".vk-status-bar-text");
    if (!textEl)
      return;
    if (!this.isInCardsFolder(file)) {
      textEl.textContent = "\u2014";
      this.statusBarItem.className = "vk-status-bar";
      return;
    }
    const isSynced = await this.frontmatter.isSynced(file);
    if (!isSynced) {
      textEl.textContent = "Not synced";
      this.statusBarItem.className = "vk-status-bar vk-status-unsynced";
      return;
    }
    const status = await this.frontmatter.getStatus(file);
    this.statusBarItem.className = `vk-status-bar vk-status-${status || "unknown"}`;
    switch (status) {
      case "notsynced":
        textEl.textContent = "Not synced";
        break;
      case "todo":
        textEl.textContent = "To Do";
        break;
      case "inprogress":
        textEl.textContent = "Executing...";
        break;
      case "inreview":
        textEl.textContent = "In Review";
        break;
      case "done":
        textEl.textContent = "Done";
        break;
      case "cancelled":
        textEl.textContent = "Cancelled";
        break;
      case "deleted":
        textEl.textContent = "Deleted";
        break;
      default:
        textEl.textContent = "Synced";
    }
  }
  showRibbonMenu(evt) {
    const menu = new import_obsidian9.Menu();
    menu.addItem(
      (item) => item.setTitle("New KanDo card").setIcon("list-plus").onClick(() => {
        this.createNewCard();
      })
    );
    menu.addItem(
      (item) => item.setTitle("Settings").setIcon("settings").onClick(() => {
        this.app.setting.open();
        this.app.setting.openTabById("kando");
      })
    );
    menu.showAtMouseEvent(evt);
  }
  async pushCard(file) {
    await this.pushCardWithCallback(file);
  }
  // Push card with optional callback (used for chained push+execute)
  async pushCardWithCallback(file, onComplete) {
    var _a;
    try {
      const isSynced = await this.frontmatter.isSynced(file);
      const title = await this.frontmatter.getTitle(file);
      if (isSynced) {
        await this.pushCardQuiet(file);
        new import_obsidian9.Notice("Card updated in Vibe Kanban");
        if (onComplete) {
          try {
            await onComplete();
          } catch (error) {
            const message = formatErrorMessage("Callback failed", error);
            console.error("[KanDo]", message);
            new import_obsidian9.Notice(message);
          }
        }
      } else {
        const fm = await this.frontmatter.read(file);
        const projectId = fm.vk_project_id || this.settings.defaultProjectId;
        if (projectId) {
          const description = await this.frontmatter.getDescription(file);
          const task = await this.api.createTask({
            project_id: projectId,
            title,
            description
          });
          let projectName = fm.vk_project_name || "";
          if (!projectName) {
            const projects = await this.api.getProjects();
            projectName = ((_a = projects.find((p) => p.id === projectId)) == null ? void 0 : _a.name) || "";
          }
          await this.frontmatter.markSynced(file, task.id, projectId, projectName, task.status);
          this.updateTaskIndex(task.id, file.path);
          if (this.statusPoller) {
            this.statusPoller.trackTask(task.id);
          }
          await this.updateStatusBar(file);
          await this.updateToolbarButtons(file);
          if (onComplete) {
            try {
              await onComplete();
            } catch (error) {
              const message = formatErrorMessage("Callback failed", error);
              console.error("[KanDo]", message);
              new import_obsidian9.Notice(message);
            }
          }
        } else {
          const projects = await this.api.getProjects();
          if (projects.length === 0) {
            new import_obsidian9.Notice("No projects found in Vibe Kanban");
            return;
          }
          new PushModal(
            this.app,
            title,
            projects,
            this.settings.defaultProjectId,
            async (selectedProjectId) => {
              var _a2;
              const description = await this.frontmatter.getDescription(file);
              const task = await this.api.createTask({
                project_id: selectedProjectId,
                title,
                description
              });
              const projectName = ((_a2 = projects.find((p) => p.id === selectedProjectId)) == null ? void 0 : _a2.name) || "";
              await this.frontmatter.markSynced(file, task.id, selectedProjectId, projectName, task.status);
              this.updateTaskIndex(task.id, file.path);
              if (this.statusPoller) {
                this.statusPoller.trackTask(task.id);
              }
              await this.updateStatusBar(file);
              await this.updateToolbarButtons(file);
              if (onComplete) {
                try {
                  await onComplete();
                } catch (error) {
                  const message = formatErrorMessage("Callback failed", error);
                  console.error("[KanDo]", message);
                  new import_obsidian9.Notice(message);
                }
              }
            }
          ).open();
        }
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian9.Notice(`Failed to push: ${message}`);
    }
  }
  async pushCardQuiet(file) {
    const fm = await this.frontmatter.read(file);
    if (!fm.vk_task_id)
      return;
    const title = await this.frontmatter.getTitle(file);
    const description = await this.frontmatter.getDescription(file);
    await this.api.updateTask(fm.vk_task_id, {
      title,
      description
    });
    await this.frontmatter.update(file, {
      vk_last_synced: new Date().toISOString()
    });
  }
  async executeCard(file) {
    var _a;
    try {
      let fm = await this.frontmatter.read(file);
      let taskId = fm.vk_task_id;
      let projectId = fm.vk_project_id || this.settings.defaultProjectId;
      if (!taskId) {
        if (!projectId) {
          new import_obsidian9.Notice("No project configured - please set a default project in settings");
          return;
        }
        const title2 = await this.frontmatter.getTitle(file);
        const description = await this.frontmatter.getDescription(file);
        const task = await this.api.createTask({
          project_id: projectId,
          title: title2,
          description
        });
        let projectName = fm.vk_project_name || "";
        if (!projectName) {
          const projects = await this.api.getProjects();
          projectName = ((_a = projects.find((p) => p.id === projectId)) == null ? void 0 : _a.name) || "";
        }
        taskId = task.id;
        await this.frontmatter.markSynced(file, task.id, projectId, projectName, task.status);
        this.updateTaskIndex(task.id, file.path);
        if (this.statusPoller) {
          this.statusPoller.trackTask(taskId);
        }
      }
      if (!taskId || !projectId) {
        new import_obsidian9.Notice("Card not properly synced");
        return;
      }
      await this.pushCardQuiet(file);
      const title = await this.frontmatter.getTitle(file);
      let branches = [];
      let executorOptions = [];
      try {
        const [branchesResult, profilesResult] = await Promise.all([
          this.api.getProjectBranches(projectId).catch(() => null),
          this.api.getProfiles().catch(() => null)
        ]);
        branches = branchesResult || [
          { name: this.settings.defaultBranch, is_current: true, is_remote: false }
        ];
        if (profilesResult) {
          executorOptions = parseExecutorProfiles(profilesResult);
        }
      } catch (e) {
        branches = [{ name: this.settings.defaultBranch, is_current: true, is_remote: false }];
      }
      if (executorOptions.length === 0) {
        executorOptions = [
          { executor: DEFAULT_EXECUTOR, variants: [...DEFAULT_EXECUTOR_VARIANTS] }
        ];
      }
      new ExecuteModal(
        this.app,
        title,
        branches,
        executorOptions,
        this.settings.defaultExecutor,
        this.settings.defaultVariant,
        this.settings.defaultBranch,
        async (executor, variant, branch) => {
          const attempt = await this.api.createTaskAttempt({
            task_id: taskId,
            executor_profile_id: {
              executor,
              variant
            },
            base_branch: branch
          });
          await this.frontmatter.updateExecutionStatus(
            file,
            "inprogress",
            attempt.id,
            attempt.branch,
            true
            // executing
          );
          await this.updateStatusBar(file);
          if (taskId && projectId) {
            if (this.statusPoller) {
              this.statusPoller.setKnownState(taskId, "inprogress", true);
              this.statusPoller.addProject(projectId);
            } else if (this.settings.autoSyncStatus) {
              await this.updateWebSocketConnection();
            }
          }
        }
      ).open();
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian9.Notice(`Failed to execute: ${message}`);
    }
  }
  async pullStatus(file) {
    const targetFile = file || this.getActiveFile();
    if (!targetFile) {
      new import_obsidian9.Notice("No file open");
      return;
    }
    if (!this.isInCardsFolder(targetFile)) {
      new import_obsidian9.Notice("Not a card file");
      return;
    }
    try {
      const isSynced = await this.frontmatter.isSynced(targetFile);
      if (!isSynced) {
        new import_obsidian9.Notice("Card not synced with Vibe Kanban");
        return;
      }
      const fm = await this.frontmatter.read(targetFile);
      if (!fm.vk_task_id) {
        new import_obsidian9.Notice("No task ID found");
        return;
      }
      const task = await this.api.getTask(fm.vk_task_id);
      let attempts = [];
      try {
        attempts = await this.api.getTaskAttempts(fm.vk_task_id);
      } catch (e) {
      }
      const latestAttempt = attempts[attempts.length - 1];
      await this.frontmatter.updateExecutionStatus(
        targetFile,
        task.status,
        latestAttempt == null ? void 0 : latestAttempt.id,
        latestAttempt == null ? void 0 : latestAttempt.branch,
        task.has_in_progress_attempt
      );
      await this.updateStatusBar(targetFile);
      new StatusModal(
        this.app,
        task,
        attempts,
        this.settings.vkUrl,
        fm.vk_project_id || "",
        async () => {
          const refreshedTask = await this.api.getTask(fm.vk_task_id);
          let refreshedAttempts = [];
          try {
            refreshedAttempts = await this.api.getTaskAttempts(fm.vk_task_id);
          } catch (e) {
          }
          const latestAttempt2 = refreshedAttempts[refreshedAttempts.length - 1];
          await this.frontmatter.updateExecutionStatus(
            targetFile,
            refreshedTask.status,
            latestAttempt2 == null ? void 0 : latestAttempt2.id,
            latestAttempt2 == null ? void 0 : latestAttempt2.branch,
            refreshedTask.has_in_progress_attempt
          );
          await this.updateStatusBar(targetFile);
          return { task: refreshedTask, attempts: refreshedAttempts };
        }
      ).open();
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian9.Notice(`Failed to pull status: ${message}`);
    }
  }
  async openInVK(file) {
    const targetFile = file || this.getActiveFile();
    if (!targetFile) {
      new import_obsidian9.Notice("No file open");
      return;
    }
    try {
      const fm = await this.frontmatter.read(targetFile);
      if (!fm.vk_task_id) {
        new import_obsidian9.Notice("Card not synced with Vibe Kanban");
        return;
      }
      if (!fm.vk_project_id) {
        new import_obsidian9.Notice("Missing project ID - cannot open task");
        return;
      }
      const taskPath = `/projects/${fm.vk_project_id}/tasks/${fm.vk_task_id}`;
      if (this.settings.openInObsidian) {
        await this.openVibeKanbanView(taskPath);
      } else {
        const baseUrl = this.settings.vkUrl.replace(/\/+$/, "");
        window.open(`${baseUrl}${taskPath}`, "_blank");
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian9.Notice(`Failed to open: ${message}`);
    }
  }
  /**
   * Open the Vibe Kanban view in a new tab.
   * Optionally navigate to a specific path within VK.
   * If no path provided and defaultProjectId is set, opens the project's task board.
   */
  async openVibeKanbanView(path = "") {
    if (!path && this.settings.defaultProjectId) {
      path = `/projects/${this.settings.defaultProjectId}/tasks`;
    }
    const existingLeaves = this.app.workspace.getLeavesOfType(VIBE_KANBAN_VIEW_TYPE);
    if (existingLeaves.length > 0) {
      const leaf2 = existingLeaves[0];
      this.app.workspace.revealLeaf(leaf2);
      if (path) {
        const view2 = leaf2.view;
        view2.navigateTo(path);
      }
      return;
    }
    const leaf = this.app.workspace.getLeaf("tab");
    await leaf.setViewState({
      type: VIBE_KANBAN_VIEW_TYPE,
      active: true,
      state: { vkUrl: this.settings.vkUrl, path }
    });
    const view = leaf.view;
    if (view && view.setUrl) {
      view.setUrl(this.settings.vkUrl, path);
    }
    this.app.workspace.revealLeaf(leaf);
  }
  /**
   * Create a new card file with native template functionality.
   * @param targetFolder Optional folder path to create the card in
   */
  async createNewCard(targetFolder) {
    try {
      let folder = "";
      if (targetFolder) {
        const normalized = targetFolder.replace(/\\/g, "/").replace(/\/+/g, "/").replace(/^\/|\/$/g, "");
        if (normalized.includes("..") || normalized.startsWith("/")) {
          new import_obsidian9.Notice("Invalid folder path");
          return;
        }
        const folderObj = this.app.vault.getAbstractFileByPath(normalized);
        if (folderObj instanceof import_obsidian9.TFolder) {
          folder = normalized;
        } else if (!folderObj) {
          folder = normalized;
        } else {
          new import_obsidian9.Notice("Invalid folder path");
          return;
        }
      } else {
        folder = this.settings.cardsFolder || "";
      }
      const result = await this.showCreateCardModal("Untitled");
      if (!result)
        return;
      const filePath = this.generateUniqueFilePath(folder, result.title);
      const content = this.buildCardContent(result);
      if (folder) {
        const folderExists = this.app.vault.getAbstractFileByPath(folder);
        if (!folderExists) {
          await this.app.vault.createFolder(folder);
        }
      }
      const file = await this.app.vault.create(filePath, content);
      const leaf = this.app.workspace.getLeaf();
      await leaf.openFile(file);
      setTimeout(() => {
        if (leaf.view instanceof import_obsidian9.MarkdownView) {
          this.addToolbarToView(leaf.view);
          if (leaf.view.file) {
            this.updateToolbarButtons(leaf.view.file);
          }
        }
      }, 50);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian9.Notice(`Failed to create card: ${message}`);
    }
  }
  /**
   * Generate a unique file path, appending numbers if needed to avoid duplicates.
   */
  generateUniqueFilePath(folder, title) {
    const sanitizedTitle = title.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim();
    const basePath = folder ? `${folder}/${sanitizedTitle}` : sanitizedTitle;
    let filePath = `${basePath}.md`;
    let counter = 1;
    while (this.app.vault.getAbstractFileByPath(filePath)) {
      filePath = `${basePath} ${counter}.md`;
      counter++;
    }
    return filePath;
  }
  /**
   * Build the markdown content for a new card file.
   */
  buildCardContent(result) {
    const frontmatter = `---
title: ${result.title}
vk_status: notsynced
vk_project_name: ${result.project.name}
vk_project_id: ${result.project.id}
---`;
    const body = result.description || "";
    return `${frontmatter}

${body}
`;
  }
  /**
   * Public API for Templater integration.
   * Shows a single modal to create a new card with project, title, and description.
   * Returns null if cancelled.
   */
  async showCreateCardModal(defaultTitle = "Untitled") {
    try {
      const projects = await this.api.getProjects();
      if (projects.length === 0) {
        new import_obsidian9.Notice("No projects found in Vibe Kanban");
        return null;
      }
      const modal = new CreateCardModal(
        this.app,
        projects,
        this.settings.defaultProjectId,
        defaultTitle
      );
      return await modal.openAndWait();
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian9.Notice(`Failed to load projects: ${message}`);
      return null;
    }
  }
};
